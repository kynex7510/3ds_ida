CREATE TABLE syscalls(
    id INT PRIMARY KEY,
    name VARCHAR(64) NOT NULL,
    signature VARCHAR(256) NOT NULL
);

CREATE UNIQUE INDEX syscall_names ON syscalls (name);

INSERT INTO syscalls (id, name, signature) VALUES
(0x01, 'ControlMemory', 'SvcResult32 __usercall svcControlMemory@<r0, r1>(MemOp op@<r0>, u32 addr0@<r1>, u32 addr1@<r2>, u32 size@<r3>, MemPerm perm@<r4>);'),
(0x02, 'QueryMemory', 'SvcResultQueryMemory __usercall svcQueryMemory@<r0, r1, r2, r3, r4, r5>(MemInfo* info@<r0>, PageInfo* out@<r1>, u32 addr@<r2>);'),
(0x03, 'ExitProcess', 'void svcExitProcess(void) __attribute__((noreturn));'),
(0x04, 'GetProcessAffinityMask', 'Result __usercall svcGetProcessAffinityMask@<r0>(u8* affinitymask@<r0>, Handle process@<r1>, s32 processorcount@<r2);'),
(0x05, 'SetProcessAffinityMask', 'Result __usercall svcSetProcessAffinityMask@<r0>(Handle process@<r0>, const u8* affinitymask@<r1>, s32 processorcount@<r2>);'),
(0x06, 'GetProcessIdealProcessor', 'SvcResult32 __usercall svcGetProcessIdealProcessor@<r0, r1>(Handle process@<r1>);'),
(0x07, 'SetProcessIdealProcessor', 'Result __usercall svcSetProcessIdealProcessor@<r0>(Handle process@<r0>, s32 processorid@<r1>);'),
(0x08, 'CreateThread', 'SvcResultHandle __usercall svcCreateThread@<r0, r1>(s32 thread_priority@<r0>, ThreadFunc entrypoint@<r1>, u32 arg@<r2>, u32* stack_top@<r3>, s32 processor_id@<r4>);'),
(0x09, 'ExitThread', 'void svcExitThread(void) __attribute__((noreturn));'),
(0x0A, 'SleepThread', 'void __usercall svcSleepThread(s64 ns@<r0, r1>);'),
(0x0B, 'GetThreadPriority', 'SvcResult32 __usercall svcGetThreadPriority@<r0, r1>(Handle handle@<r1>);'),
(0x0C, 'SetThreadPriority', 'Result __usercall svcSetThreadPriority@<r0>(Handle thread@<r0>, s32 prio@<r1>);'),
(0x0D, 'GetThreadAffinityMask', 'Result __usercall svcGetThreadAffinityMask@<r0>(u8* affinitymask@<r0>, Handle thread@<r1>, s32 processorcount@<r2>);'),
(0x0E, 'SetThreadAffinityMask', 'Result __usercall svcSetThreadAffinityMask@<r0>(Handle thread@<r0>, const u8* affinitymask@<r1>, s32 processorcount@<r2>);'),
(0x0F, 'GetThreadIdealProcessor', 'SvcResult32 __usercall svcGetThreadIdealProcessor@<r0, r1>(Handle thread@<r1>);'),
(0x10, 'SetThreadIdealProcessor', 'Result __usercalL svcSetThreadIdealProcessor@<r0>(Handle thread@<r0>, s32 processorid@<r1>);'),
(0x11, 'GetProcessorId', 's32 __usercall svcGetProcessorId@<r0>(void);'),
(0x12, 'Run', 'Result __usercall svcRun@<r0>(Handle process@<r0>, s32 priority@<r1>, u32 stack_size@<r2>, s32 argc@<r3>, u16* argv@<r4>, u16* envp@<r5>);'),
(0x13, 'CreateMutex', 'SvcCreateHandleesult __usercall svcCreateMutex@<r0, r1>(bool initially_locked@<r1>);'),
(0x14, 'ReleaseMutex', 'Result __usercall svcReleaseMutex@<r0>(Handle handle@<r0>);'),
(0x15, 'CreateSemaphore', 'SvcResultHandle __usercall svcCreateSemaphore@<r0, r1>(s32 initial_count@<r1>, s32 max_count@<r2>);'),
(0x16, 'ReleaseSemaphore', 'SvcResult32 __usercall svcReleaseSemaphore@<r0, r1>(Handle semaphore@<r1>, s32 release_count@<r2>);'),
(0x17, 'CreateEvent', 'SvcResultHandle __usercall svcCreateEvent@<r0, r1>(ResetType reset_type@<r1>);'),
(0x18, 'SignalEvent', 'Result __usercall svcSignalEvent@<r0>(Handle handle@<r0>);'),
(0x19, 'ClearEvent', 'Result __usercall svcClearEvent@<r0>(Handle handle@<r0>);'),
(0x1A, 'CreateTimer', 'SvcResultHandle __usercall svcCreateTimer@<r0, r1>(ResetType reset_type@<r1>);'),
(0x1B, 'SetTimer', 'Result __usercall svcSetTimer@<r0>(Handle timer@<r0>, s64 initial@<r2, r3>, s64 interval@<r1, r4>);'),
(0x1C, 'CancelTimer', 'Result __usercall svcCancelTimer@<r0>(Handle timer@<r0>);'),
(0x1D, 'ClearTimer', 'Result __usercall svcClearTimer@<r0>(Handle timer@<r0>);'),
(0x1E, 'CreateMemory', 'SvcResultHandle __usercall svcCreateMemoryBlock@<r0, r1>(MemPerm other_perm@<r0>, u32 addr@<r1>, u32 size@<r2>, MemPerm my_perm@<r3>);'),
(0x1F, 'MapMemoryBlock', 'Result __usercall svcMapMemoryBlock@<r0>(Handle memblock@<r0>, u32 addr@<r1>, MemPerm my_perm@<r2>, MemPerm other_perm@<r3>);'),
(0x20, 'UnmapMemoryBlock', 'Result __usercall svcUnmapMemoryBlock@<r0>(Handle memblock@<r0>, u32 addr@<r1>);'),
(0x21, 'CreateAddressArbiter', 'SvcResultHandle __usercall svcCreateAddressArbiter@<r0, r1>(void);'),
(0x22, 'ArbitrateAddress', 'Result __usercall svcArbitrateAddress@<r0>(Handle arbiter@<r0>, u32 addr@<r1>, ArbitrationType type@<r2>, s32 value@<r3>, s64 timeout_ns@<r4, r5>);'),
(0x23, 'CloseHandle', 'Result __usercall svcCloseHandle@<r0>(Handle handle@<r0>);'),
(0x24, 'WaitSynchronization', 'Result __usercall svcWaitSynchronization@<r0>(Handle handle@<r0>, s64 nanoseconds@<r2, r3>);'),
(0x25, 'WaitSynchronizationN', 'SvcResult32 __usercall svcWaitSynchronizationN@<r0, r1>(const Handle* handles@<r1>, s32 handles_num@<r2>, bool wait_all@<r3>, s64 nanoseconds@<r0, r4>);'),
(0x27, 'DuplicateHandle', 'SvcResultHandle __usercall svcDuplicateHandle@<r0, r1>(Handle original@<r1>);'),
(0x28, 'GetSystemTick', 'u64 __usercall svcGetSystemTick@<r0, r1>(void);'),
(0x29, 'GetHandleInfo', 'SvcResult64 __usercall svcGetHandleInfo@<r0, r1, r2>(Handle handle@<r1>, u32 param@<r2>);'),
(0x2A, 'GetSystemInfo', 'SvcResult64 __usercall svcGetSystemInfo@<r0, r1, r2>(u32 type@<r1>, s32 param@<r2>);'),
(0x2B, 'GetProcessInfo', 'SvcResult64 __usercall svcGetProcessInfo@<r0, r1, r2>(Handle process@<r1>, u32 type@<r2>);'),
(0x2C, 'GetThreadInfo', 'SvcResult64 __usercall svcGetThreadInfo@<r0, r1, r2>(Handle thread@<r1>, ThreadInfoType type@<r2>);'),
(0x2D, 'ConnectToPort', 'SvcResultHandle __usercall svcConnectToPort@<r0, r1>(const char* portName@<r1>);'),
(0x32, 'SendSyncRequest', 'Result __usercall svcSendSyncRequest@<r0>(Handle session@<r0>);'),
(0x33, 'OpenProcess', 'SvcResultHandle __usercall svcOpenProcess@<r0, r1>(u32 processId@<r1>);'),
(0x34, 'OpenThread', 'SvcResultHandle __usercall svcOpenThread@<r0, r1>(Handle process@<r0>, u32 threadId@<r1>);'),
(0x35, 'GetProcessId', 'SvcResult32 __usercall svcGetProcessId@<r0, r1>(Handle handle@<r1>);'),
(0x36, 'GetProcessIdOfThread', 'SvcResult32 __usercall svcGetProcessIdOfThread@<r0, r1>(Handle handle@<r1>);'),
(0x37, 'GetThreadId', 'SvcResult32 __usercall svcGetThreadId@<r0, r1>(Handle handle@<r1>);'),
(0x38, 'GetResourceLimit', 'SvcResultHandle __usercall svcGetResourceLimit@<r0, r1>(Handle process@<r1>);'),
(0x39, 'GetResourceLimitLimitValues', 'Result __usercall svcGetResourceLimitLimitValues@<r0>(s64* values@<r0>, Handle resourceLimit@<r1>, ResourceLimitType* names@<r2>, s32 nameCount@<r3>);'),
(0x3A, 'GetResourceLimitCurrentValues', 'Result __usercall svcGetResourceLimitCurrentValues@<r0>(s64* values@<r0>, Handle resourceLimit@<r1>, ResourceLimitType* names@<r2>, s32 nameCount@<r3>);'),
(0x3C, 'Break', 'void __usercall svcBreak(UserBreakType breakReason@<r0>) __attribute__((noreturn));'),
(0x3D, 'OutputDebugString', 'Result __usercall svcOutputDebugString@<r0>(const char* str@<r0>, s32 length@<r1>);'),
(0x3E, 'ControlPerformanceCounter', 'SvcResult64 __usercall svcControlPerformanceCounter@<r0, r2, r1>(PerfCounterOperation op@<r1>, u32 param1@<r2>, u64 param2@<r3, r0>);'),
(0x47, 'CreatePort', 'SvcResultHandlePair __usercall svcCreatePort@<r0, r1, r2>(const char* name@<r2>, s32 maxSessions@<r3>);'),
(0x48, 'CreateSessionToPort', 'SvcResultHandle __usercall svcCreateSessionToPort@<r0, r1>(Handle clientPort@<r1>);'),
(0x49, 'CreateSession', 'SvcResultHandlePair __usercall svcCreateSession@<r0, r1, r2>(void);'),
(0x4A, 'AcceptSession', 'SvcResultHandle __usercall svcAcceptSession@<r0, r1>(Handle port@<r1>);'),
(0x4F, 'ReplyAndReceive', 'SvcResult32 __usercall svcReplyAndReceive@<r0, r1>(const Handle* handles@<r1>, s32 handleCount@<r2>, Handle replyTarget@<r3>);'),
(0x50, 'BindInterrupt', 'Result __usercall svcBindInterrupt@<r0>(u32 interruptId@<r0>, Handle eventOrSemaphore@<r1>, s32 priority@<r2>, bool isManualClear@<r3>);'),
(0x51, 'UnbindInterrupt', 'Result __usercall svcUnbindInterrupt@<r0>(u32 interruptId@<r0>, Handle eventOrSemaphore@<r1>);'),
(0x52, 'InvalidateProcessDataCache', 'Result __usercall svcInvalidateProcessDataCache@<r0>(Handle process@<r0>, u32 addr@<r1>, u32 size@<r2>);'),
(0x53, 'StoreProcessDataCache', 'Result __usercall svcStoreProcessDataCache@<r0>(Handle process@<r0>, u32 addr@<r1>, u32 size@<r2>);'),
(0x54, 'FlushProcessDataCache', 'Result __usercall svcFlushProcessDataCache@<r0>(Handle process@<r0>, u32 addr@<r1>, u32 size@<r2>);'),
(0x55, 'StartInterProcessDma', 'SvcResultHandle __usercall svcStartInterProcessDma@<r0, r1>(u32 srcAddr@<r0>, Handle dstProcess@<r1>, u32 dstAddr@<r2>, Handle srcProcess@<r3>, u32 size@<r4>, const DmaConfig *cfg@<r5>);'),
(0x56, 'StopDma', 'Result __usercall svcStopDma@<r0>(Handle dma@<r0>);'),
(0x57, 'GetDmaState', 'SvcResult8 __usercall svcGetDmaState@<r0, r1>(Handle dma@<r1>);'),
(0x58, 'RestartDma', 'Result __usercall svcRestartDma@<r0>(Handle dma@<r0>, u32 dstAddr@<r1>, u32 srcAddr@<r2>, u32 size@<r3>, s8 flags@<r4>);'),
(0x59, 'SetGpuProt', 'Result __usercall svcSetGpuProt@<r0>(bool useApplicationRestriction@<r0>);'),
(0x5A, 'SetWifiEnabled', 'Result __usercall svcSetWifiEnabled@<r0>(bool enabled@<r0>);'),
(0x60, 'DebugActiveProcess', 'SvcResultHandle __usercall svcDebugActiveProcess@<r0, r1>(u32 processId@<r1>);'),
(0x61, 'BreakDebugProcess', 'Result __usercall svcBreakDebugProcess@<r0>(Handle debug@<r0>);'),
(0x62, 'TerminateDebugProcess', 'Result __usercall svcTerminateDebugProcess@<r0>(Handle debug@<r0>);'),
(0x63, 'GetProcessDebugEvent', 'Result __usercall svcGetProcessDebugEvent@<r0>(DebugEventInfo* info@<r0>, Handle debug@<r1>);'),
(0x64, 'ContinueDebugEvent', 'Result __usercall svcContinueDebugEvent@<r0>(Handle debug@<r0>, DebugFlags flags@<r1>);'),
(0x65, 'GetProcessList', 'SvcResult32 __usercall svcGetProcessList@<r0, r1>(s32 processIdMaxCount@<r2>);'),
(0x66, 'GetThreadList', 'SvcResult32 __usercall svcGetThreadList@<r0, r1>(s32 threadIdMaxCount@<r2>, Handle process@<r3>);'),
(0x67, 'GetDebugThreadContext', 'Result __usercall svcGetDebugThreadContext@<r0>(ThreadContext* context@<r0>, Handle debug@<r1>, u32 threadId@<r2>, ThreadContextControlFlags controlFlags@<r3>);'),
(0x68, 'SetDebugThreadContext', 'Result __usercall svcSetDebugThreadContext@<r0>(Handle debug@<r0>, u32 threadId@<r1>, ThreadContext* context@<r2>, ThreadContextControlFlags controlFlags@<r3>);'),
(0x69, 'QueryDebugProcessMemory', 'SvcResultQueryMemory __usercall svcQueryDebugProcessMemory@<r0, r1, r2, r3, r4, r5>(Handle debug@<r2>, u32 addr@<r3>);'),
(0x6A, 'ReadProcessMemory', 'Result __usercall svcReadProcessMemory@<r0>(void* buffer@<r0>, Handle debug@<r1>, u32 addr@<r2>, u32 size@<r3>);'),
(0x6B, 'WriteProcessMemory', 'Result __usercall svcWriteProcessMemory@<r0>(Handle debug@<r0>, const void* buffer@<r1>, u32 addr@<r2>, u32 size@<r3>);'),
(0x6C, 'SetHardwareBreakPoint', 'Result __usercall svcSetHardwareBreakPoint@<r0>(s32 registerId@<r0>, u32 control@<r1>, u32 value@<r2>);'),
(0x6D, 'GetDebugThreadParam', 'SvcResultGetDebugThreadParam __usercall svcGetDebugThreadParam@<r0, r2, r1, r3>(u32* out@<r1>, Handle debug@<r2>, u32 threadId@<r3>, DebugThreadParameter parameter@<r0>);'),
(0x70, 'ControlProcessMemory', 'Result __usercall svcControlProcessMemory@<r0>(Handle process@<r0>, u32 addr0@<r1>, u32 addr1@<r2>, u32 size@<r3>, u32 type@<r4>, u32 perm@<r5>);'),
(0x71, 'MapProcessMemory', 'Result __usercall svcMapProcessMemory@<r0>(Handle process@<r0>, u32 destAddress@<r1>, u32 size@<r2>);'),
(0x72, 'UnmapProcessMemory', 'Result __usercall svcUnmapProcessMemory@<r0>(Handle process@<r0>, u32 destAddress@<r1>, u32 size@<r2>);'),
(0x73, 'CreateCodeSet', 'SvcResultHandle __usercall svcCreateCodeSet@<r0, r1>(u32 dataSegmentLma@<r0>, const CodeSetHeader* info@<r1>, u32 textSegmentLma@<r2>, u32 roSegmentLma@<r3>);'),
(0x75, 'CreateProcess', 'SvcResultHandle __usercall svcCreateProcess@<r0, r1>(Handle codeset@<r1>, const u32* arm11KernelCaps@<r2>, s32 numArm11KernelCaps@<r3>);'),
(0x76, 'TerminateProcess', 'Result __usercall svcTerminateProcess@<r0>(Handle process@<r0>);'),
(0x77, 'SetProcessResourceLimits', 'Result __usercall svcSetProcessResourceLimits@<r0>(Handle process@<r0>, Handle resourceLimit@<r1>);'),
(0x78, 'CreateResourceLimit', 'SvcResultHandle __usercall svcCreateResourceLimit@<r0, r1>(void);'),
(0x79, 'SetResourceLimitValues', 'Result __usercall svcSetResourceLimitValues@<r0>(Handle resourceLimit@<r0>, const ResourceLimitType* names@<r1>, const s64* values@<r2>, s32 nameCount@<r3>);'),
(0x7B, 'Backdoor', 'Result __usercall svcBackdoor@<r0>(s32 (*callback)(void)@<r0>);'),
(0x7C, 'KernelSetState', 'Result __usercall svcKernelSetState@<r0>(u32 type@<r0>, ...);'),
(0x7D, 'QueryProcessMemory', 'SvcResultQueryMemory __usercall svcQueryProcessMemory@<r0, r1, r2, r3, r4, r5>(Handle process@<r2>, u32 addr@<r3>);');